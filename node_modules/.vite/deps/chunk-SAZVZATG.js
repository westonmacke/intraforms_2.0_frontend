import {
  IN_BROWSER,
  defer,
  focusableChildren,
  getCurrentInstance,
  propsFactory
} from "./chunk-TKFNZHNB.js";
import {
  nextTick,
  onBeforeUnmount,
  toRef,
  toValue,
  watch
} from "./chunk-QCNYTOAH.js";

// node_modules/vuetify/lib/composables/delay.js
var makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props, cb) {
  let clearDelay = () => {
  };
  function runDelay(isOpening, options) {
    clearDelay == null ? void 0 : clearDelay();
    const delay = isOpening ? props.openDelay : props.closeDelay;
    const normalizedDelay = Math.max((options == null ? void 0 : options.minDelay) ?? 0, Number(delay ?? 0));
    return new Promise((resolve) => {
      clearDelay = defer(normalizedDelay, () => {
        cb == null ? void 0 : cb(isOpening);
        resolve(isOpening);
      });
    });
  }
  function runOpenDelay() {
    return runDelay(true);
  }
  function runCloseDelay(options) {
    return runDelay(false, options);
  }
  return {
    clearDelay,
    runOpenDelay,
    runCloseDelay
  };
}

// node_modules/vuetify/lib/composables/focusTrap.js
var makeFocusTrapProps = propsFactory({
  retainFocus: Boolean,
  captureFocus: Boolean,
  /** @deprecated */
  disableInitialFocus: Boolean
}, "focusTrap");
var registry = /* @__PURE__ */ new Map();
function onKeydown(e) {
  const activeElement = document.activeElement;
  if (e.key !== "Tab" || !activeElement) return;
  const parentTraps = Array.from(registry.values()).filter((_ref) => {
    var _a;
    let {
      isActive,
      contentEl
    } = _ref;
    return isActive.value && ((_a = contentEl.value) == null ? void 0 : _a.contains(activeElement));
  }).map((x) => x.contentEl.value);
  let closestTrap;
  let currentParent = activeElement.parentElement;
  while (currentParent) {
    if (parentTraps.includes(currentParent)) {
      closestTrap = currentParent;
      break;
    }
    currentParent = currentParent.parentElement;
  }
  if (!closestTrap) return;
  const focusable = focusableChildren(closestTrap).filter((x) => x.tabIndex >= 0);
  if (!focusable.length) return;
  const active = document.activeElement;
  if (focusable.length === 1 && focusable[0].classList.contains("v-list") && focusable[0].contains(active)) {
    e.preventDefault();
    return;
  }
  const firstElement = focusable[0];
  const lastElement = focusable[focusable.length - 1];
  if (e.shiftKey && (active === firstElement || firstElement.classList.contains("v-list") && firstElement.contains(active))) {
    e.preventDefault();
    lastElement.focus();
  }
  if (!e.shiftKey && (active === lastElement || lastElement.classList.contains("v-list") && lastElement.contains(active))) {
    e.preventDefault();
    firstElement.focus();
  }
}
function useFocusTrap(props, _ref2) {
  let {
    isActive,
    localTop,
    activatorEl,
    contentEl
  } = _ref2;
  const trapId = Symbol("trap");
  watch(() => props.retainFocus, (val) => {
    if (val) {
      registry.set(trapId, {
        isActive,
        contentEl
      });
    } else {
      registry.delete(trapId);
    }
  }, {
    immediate: true
  });
  let focusTrapSuppressed = false;
  let focusTrapSuppressionTimeout = -1;
  async function onPointerdown() {
    focusTrapSuppressed = true;
    focusTrapSuppressionTimeout = window.setTimeout(() => {
      focusTrapSuppressed = false;
    }, 100);
  }
  async function captureOnFocus(e) {
    var _a;
    const before = e.relatedTarget;
    const after = e.target;
    document.removeEventListener("pointerdown", onPointerdown);
    document.removeEventListener("keydown", captureOnKeydown);
    await nextTick();
    if (isActive.value && !focusTrapSuppressed && before !== after && contentEl.value && // We're the menu without open submenus or overlays
    toValue(localTop) && // It isn't the document or the container body
    ![document, contentEl.value].includes(after) && // It isn't inside the container body
    !contentEl.value.contains(after)) {
      const focusable = focusableChildren(contentEl.value);
      (_a = focusable[0]) == null ? void 0 : _a.focus();
    }
  }
  function captureOnKeydown(e) {
    if (e.key !== "Tab") return;
    document.removeEventListener("keydown", captureOnKeydown);
    if (isActive.value && contentEl.value && e.target && !contentEl.value.contains(e.target)) {
      const allFocusableElements = focusableChildren(document.documentElement);
      if (e.shiftKey && e.target === allFocusableElements.at(0) || !e.shiftKey && e.target === allFocusableElements.at(-1)) {
        const focusable = focusableChildren(contentEl.value);
        if (focusable.length > 0) {
          e.preventDefault();
          focusable[0].focus();
        }
      }
    }
  }
  const shouldCapture = toRef(() => isActive.value && props.captureFocus && !props.disableInitialFocus);
  IN_BROWSER && watch(shouldCapture, (val) => {
    if (val) {
      document.addEventListener("pointerdown", onPointerdown);
      document.addEventListener("focusin", captureOnFocus, {
        once: true
      });
      document.addEventListener("keydown", captureOnKeydown);
    } else {
      document.removeEventListener("pointerdown", onPointerdown);
      document.removeEventListener("focusin", captureOnFocus);
      document.removeEventListener("keydown", captureOnKeydown);
    }
  }, {
    immediate: true
  });
  onBeforeUnmount(() => {
    clearTimeout(focusTrapSuppressionTimeout);
    document.removeEventListener("pointerdown", onPointerdown);
    document.removeEventListener("focusin", captureOnFocus);
    document.removeEventListener("keydown", captureOnKeydown);
  });
  IN_BROWSER && document.addEventListener("keydown", onKeydown);
}

// node_modules/vuetify/lib/composables/scopeId.js
function useScopeId() {
  const vm = getCurrentInstance("useScopeId");
  const scopeId = vm.vnode.scopeId;
  return {
    scopeId: scopeId ? {
      [scopeId]: ""
    } : void 0
  };
}

export {
  makeDelayProps,
  useDelay,
  makeFocusTrapProps,
  useFocusTrap,
  useScopeId
};
//# sourceMappingURL=chunk-SAZVZATG.js.map
