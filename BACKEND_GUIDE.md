# Intraforms 2.0 - Backend API Implementation Guide

Complete guide for implementing the ASP.NET Core Web API backend with JWT authentication and SQL Server integration.

---

## üìã Overview

This backend will provide:
- JWT authentication with refresh tokens
- SQL Server database integration
- User login/registration
- Role-based access control (RBAC)
- Protected API endpoints
- RESTful API design

**Tech Stack:**
- ASP.NET Core 8.0 Web API
- Entity Framework Core / Dapper
- SQL Server
- JWT Bearer Authentication
- BCrypt.Net for password hashing
- CORS enabled
- HTTPS on port 5001

---

## üöÄ Quick Start

### 1. Create Backend Project

```bash
# Create project directory (outside the frontend folder)
mkdir intraforms_backend
cd intraforms_backend

# Create ASP.NET Core Web API project
dotnet new webapi -n IntraformsAPI
cd IntraformsAPI

# Install required NuGet packages
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Dapper
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package BCrypt.Net-Next
dotnet add package System.IdentityModel.Tokens.Jwt
```

### 2. Project Structure

```
IntraformsAPI/
‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îú‚îÄ‚îÄ AuthController.cs       # Login, register, refresh
‚îÇ   ‚îî‚îÄ‚îÄ UsersController.cs      # User management
‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îú‚îÄ‚îÄ User.cs
‚îÇ   ‚îú‚îÄ‚îÄ Role.cs
‚îÇ   ‚îú‚îÄ‚îÄ Permission.cs
‚îÇ   ‚îú‚îÄ‚îÄ LoginRequest.cs
‚îÇ   ‚îî‚îÄ‚îÄ AuthResponse.cs
‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îú‚îÄ‚îÄ IAuthService.cs
‚îÇ   ‚îú‚îÄ‚îÄ AuthService.cs
‚îÇ   ‚îú‚îÄ‚îÄ IUserService.cs
‚îÇ   ‚îî‚îÄ‚îÄ UserService.cs
‚îú‚îÄ‚îÄ Data/
‚îÇ   ‚îî‚îÄ‚îÄ DapperContext.cs        # Database connection
‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îî‚îÄ‚îÄ PermissionMiddleware.cs # Permission checking
‚îú‚îÄ‚îÄ Helpers/
‚îÇ   ‚îú‚îÄ‚îÄ JwtHelper.cs            # JWT generation/validation
‚îÇ   ‚îî‚îÄ‚îÄ PasswordHelper.cs       # Password hashing
‚îú‚îÄ‚îÄ appsettings.json            # Configuration
‚îú‚îÄ‚îÄ appsettings.Development.json
‚îú‚îÄ‚îÄ Program.cs                  # Main entry point
‚îî‚îÄ‚îÄ IntraformsAPI.csproj
```

---

## üìÅ File Implementation

### appsettings.json

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost,1433;Database=SampleDB;User Id=sa;Password=Skittles123!;TrustServerCertificate=True;"
  },
  "Jwt": {
    "Secret": "your-super-secret-jwt-key-change-this-in-production-at-least-32-characters",
    "RefreshSecret": "your-refresh-secret-key-change-this-in-production-at-least-32-characters",
    "Issuer": "IntraformsAPI",
    "Audience": "IntraformsFrontend",
    "ExpiresInMinutes": 60,
    "RefreshExpiresInDays": 7
  },
  "Cors": {
    "AllowedOrigins": ["http://localhost:3000", "https://localhost:3000"]
  }
}
```

### appsettings.Development.json

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information"
    }
  }
}
```

### .gitignore

```
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.

# User-specific files
*.suo
*.user
*.userosscache
*.sln.docstates

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Bb]in/
[Oo]bj/

# Visual Studio cache/options directory
.vs/

# .NET
project.lock.json
project.fragment.lock.json
artifacts/

*.log
appsettings.*.json
!appsettings.Development.json
```

### Program.cs

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using IntraformsAPI.Data;
using IntraformsAPI.Services;
using IntraformsAPI.Helpers;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Database
builder.Services.AddSingleton<DapperContext>();

// Services
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddSingleton<JwtHelper>();
builder.Services.AddSingleton<PasswordHelper>();

// JWT Authentication
var jwtSecret = builder.Configuration["Jwt:Secret"];
var key = Encoding.ASCII.GetBytes(jwtSecret);

builder.Services.AddAuthentication(x =>
{
    x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(x =>
{
    x.RequireHttpsMetadata = false;
    x.SaveToken = true;
    x.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(key),
        ValidateIssuer = true,
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidateAudience = true,
        ValidAudience = builder.Configuration["Jwt:Audience"],
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero
    };
});

// CORS
var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>();
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.WithOrigins(allowedOrigins)
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials();
    });
});

// HTTPS Configuration
builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenLocalhost(5001, listenOptions =>
    {
        listenOptions.UseHttps();
    });
});

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseCors("AllowFrontend");

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

// Health check endpoint
app.MapGet("/api/health", () => new { status = "ok", message = "Intraforms API is running" });

app.Run();
```

### Data/DapperContext.cs

```csharp
using System.Data;
using Microsoft.Data.SqlClient;

namespace IntraformsAPI.Data
{
    public class DapperContext
    {
        private readonly IConfiguration _configuration;
        private readonly string _connectionString;

        public DapperContext(IConfiguration configuration)
        {
            _configuration = configuration;
            _connectionString = _configuration.GetConnectionString("DefaultConnection");
        }

        public IDbConnection CreateConnection()
            => new SqlConnection(_connectionString);
    }
}
```

### Helpers/JwtHelper.cs

```csharp
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace IntraformsAPI.Helpers
{
    public class JwtHelper
    {
        private readonly IConfiguration _configuration;

        public JwtHelper(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        public string GenerateToken(int userId, string username, List<string> roles, List<object> permissions)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var secret = _configuration["Jwt:Secret"];
            var key = Encoding.ASCII.GetBytes(secret);

            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, userId.ToString()),
                new Claim(ClaimTypes.Name, username),
                new Claim("userId", userId.ToString()),
                new Claim("username", username)
            };

            // Add roles
            foreach (var role in roles)
            {
                claims.Add(new Claim(ClaimTypes.Role, role));
            }

            // Add permissions as JSON string
            claims.Add(new Claim("permissions", System.Text.Json.JsonSerializer.Serialize(permissions)));

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.UtcNow.AddMinutes(int.Parse(_configuration["Jwt:ExpiresInMinutes"])),
                Issuer = _configuration["Jwt:Issuer"],
                Audience = _configuration["Jwt:Audience"],
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }

        public string GenerateRefreshToken(int userId)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var secret = _configuration["Jwt:RefreshSecret"];
            var key = Encoding.ASCII.GetBytes(secret);

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[] { new Claim("userId", userId.ToString()) }),
                Expires = DateTime.UtcNow.AddDays(int.Parse(_configuration["Jwt:RefreshExpiresInDays"])),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }

        public ClaimsPrincipal ValidateRefreshToken(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var secret = _configuration["Jwt:RefreshSecret"];
            var key = Encoding.ASCII.GetBytes(secret);

            try
            {
                var principal = tokenHandler.ValidateToken(token, new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ValidateLifetime = true,
                    ClockSkew = TimeSpan.Zero
                }, out SecurityToken validatedToken);

                return principal;
            }
            catch
            {
                return null;
            }
        }
    }
}
```

### Helpers/PasswordHelper.cs

```csharp
namespace IntraformsAPI.Helpers
{
    public class PasswordHelper
    {
        public string HashPassword(string password)
        {
            return BCrypt.Net.BCrypt.HashPassword(password);
        }

        public bool VerifyPassword(string password, string hash)
        {
            return BCrypt.Net.BCrypt.Verify(password, hash);
        }
    }
}
```

### Middleware/PermissionMiddleware.cs

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using System.Text.Json;

namespace IntraformsAPI.Middleware
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
    public class RequirePermissionAttribute : Attribute, IAuthorizationFilter
    {
        private readonly string[] _permissions;

        public RequirePermissionAttribute(params string[] permissions)
        {
            _permissions = permissions;
        }

        public void OnAuthorization(AuthorizationFilterContext context)
        {
            var user = context.HttpContext.User;

            if (!user.Identity.IsAuthenticated)
            {
                context.Result = new UnauthorizedObjectResult(new { success = false, message = "Authentication required" });
                return;
            }

            var permissionsClaim = user.Claims.FirstOrDefault(c => c.Type == "permissions");
            if (permissionsClaim == null)
            {
                context.Result = new ForbidResult();
                return;
            }

            try
            {
                var userPermissions = JsonSerializer.Deserialize<List<PermissionDto>>(permissionsClaim.Value);
                var hasPermission = userPermissions.Any(p => _permissions.Contains(p.name));

                if (!hasPermission)
                {
                    context.Result = new ObjectResult(new { success = false, message = "Insufficient permissions" })
                    {
                        StatusCode = 403
                    };
                }
            }
            catch
            {
                context.Result = new ForbidResult();
            }
        }
    }

    public class PermissionDto
    {
        public string name { get; set; }
        public string resource { get; set; }
        public string action { get; set; }
    }
}
```

### Models/LoginRequest.cs

```csharp
namespace IntraformsAPI.Models
{
    public class LoginRequest
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}
```

### Models/AuthResponse.cs

```csharp
namespace IntraformsAPI.Models
{
    public class AuthResponse
    {
        public bool Success { get; set; }
        public string Token { get; set; }
        public string RefreshToken { get; set; }
        public UserDto User { get; set; }
        public List<RoleDto> Roles { get; set; }
        public List<PermissionDto> Permissions { get; set; }
        public string Message { get; set; }
    }

    public class UserDto
    {
        public int Id { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public string First_Name { get; set; }
        public string Last_Name { get; set; }
    }

    public class RoleDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
    }

    public class PermissionDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Resource { get; set; }
        public string Action { get; set; }
        public string Description { get; set; }
    }
}
```

### Services/IAuthService.cs

```csharp
using IntraformsAPI.Models;

namespace IntraformsAPI.Services
{
    public interface IAuthService
    {
        Task<AuthResponse> LoginAsync(LoginRequest request);
        Task<AuthResponse> RefreshTokenAsync(string refreshToken);
    }
}
```

### Services/AuthService.cs

```csharp
using Dapper;
using IntraformsAPI.Data;
using IntraformsAPI.Models;
using IntraformsAPI.Helpers;
using System.Data;

namespace IntraformsAPI.Services
{
    public class AuthService : IAuthService
    {
        private readonly DapperContext _context;
        private readonly JwtHelper _jwtHelper;
        private readonly PasswordHelper _passwordHelper;

        public AuthService(DapperContext context, JwtHelper jwtHelper, PasswordHelper passwordHelper)
        {
            _context = context;
            _jwtHelper = jwtHelper;
            _passwordHelper = passwordHelper;
        }

        public async Task<AuthResponse> LoginAsync(LoginRequest request)
        {
            using var connection = _context.CreateConnection();

            // Get user
            var user = await connection.QueryFirstOrDefaultAsync<User>(
                "SELECT id, username, email, password_hash, first_name, last_name, active FROM users WHERE username = @Username AND active = 1",
                new { request.Username }
            );

            if (user == null)
            {
                return new AuthResponse { Success = false, Message = "Invalid credentials" };
            }

            // Verify password
            if (!_passwordHelper.VerifyPassword(request.Password, user.password_hash))
            {
                return new AuthResponse { Success = false, Message = "Invalid credentials" };
            }

            // Get roles
            var roles = (await connection.QueryAsync<RoleDto>(
                @"SELECT r.id, r.name, r.description
                  FROM roles r
                  INNER JOIN user_roles ur ON r.id = ur.role_id
                  WHERE ur.user_id = @UserId AND r.active = 1",
                new { UserId = user.id }
            )).ToList();

            // Get permissions
            var permissions = (await connection.QueryAsync<PermissionDto>(
                @"SELECT DISTINCT p.id, p.name, p.resource, p.action, p.description
                  FROM permissions p
                  INNER JOIN role_permissions rp ON p.id = rp.permission_id
                  INNER JOIN user_roles ur ON rp.role_id = ur.role_id
                  WHERE ur.user_id = @UserId",
                new { UserId = user.id }
            )).ToList();

            // Update last login
            await connection.ExecuteAsync(
                "UPDATE users SET last_login = GETDATE() WHERE id = @UserId",
                new { UserId = user.id }
            );

            // Generate tokens
            var roleNames = roles.Select(r => r.Name).ToList();
            var permissionsForToken = permissions.Select(p => new { p.Name, p.Resource, p.Action }).Cast<object>().ToList();

            var token = _jwtHelper.GenerateToken(user.id, user.username, roleNames, permissionsForToken);
            var refreshToken = _jwtHelper.GenerateRefreshToken(user.id);

            return new AuthResponse
            {
                Success = true,
                Token = token,
                RefreshToken = refreshToken,
                User = new UserDto
                {
                    Id = user.id,
                    Username = user.username,
                    Email = user.email,
                    First_Name = user.first_name,
                    Last_Name = user.last_name
                },
                Roles = roles,
                Permissions = permissions
            };
        }

        public async Task<AuthResponse> RefreshTokenAsync(string refreshToken)
        {
            var principal = _jwtHelper.ValidateRefreshToken(refreshToken);
            if (principal == null)
            {
                return new AuthResponse { Success = false, Message = "Invalid refresh token" };
            }

            var userIdClaim = principal.Claims.FirstOrDefault(c => c.Type == "userId");
            if (userIdClaim == null)
            {
                return new AuthResponse { Success = false, Message = "Invalid token claims" };
            }

            var userId = int.Parse(userIdClaim.Value);

            using var connection = _context.CreateConnection();

            // Get user
            var user = await connection.QueryFirstOrDefaultAsync<User>(
                "SELECT id, username, email, first_name, last_name, active FROM users WHERE id = @UserId AND active = 1",
                new { UserId = userId }
            );

            if (user == null)
            {
                return new AuthResponse { Success = false, Message = "User not found" };
            }

            // Get roles and permissions (same as login)
            var roles = (await connection.QueryAsync<RoleDto>(
                @"SELECT r.id, r.name, r.description
                  FROM roles r
                  INNER JOIN user_roles ur ON r.id = ur.role_id
                  WHERE ur.user_id = @UserId AND r.active = 1",
                new { UserId = userId }
            )).ToList();

            var permissions = (await connection.QueryAsync<PermissionDto>(
                @"SELECT DISTINCT p.id, p.name, p.resource, p.action, p.description
                  FROM permissions p
                  INNER JOIN role_permissions rp ON p.id = rp.permission_id
                  INNER JOIN user_roles ur ON rp.role_id = ur.role_id
                  WHERE ur.user_id = @UserId",
                new { UserId = userId }
            )).ToList();

            // Generate new tokens
            var roleNames = roles.Select(r => r.Name).ToList();
            var permissionsForToken = permissions.Select(p => new { p.Name, p.Resource, p.Action }).Cast<object>().ToList();

            var newToken = _jwtHelper.GenerateToken(user.id, user.username, roleNames, permissionsForToken);
            var newRefreshToken = _jwtHelper.GenerateRefreshToken(user.id);

            return new AuthResponse
            {
                Success = true,
                Token = newToken,
                RefreshToken = newRefreshToken,
                User = new UserDto
                {
                    Id = user.id,
                    Username = user.username,
                    Email = user.email,
                    First_Name = user.first_name,
                    Last_Name = user.last_name
                },
                Roles = roles,
                Permissions = permissions
            };
        }

        private class User
        {
            public int id { get; set; }
            public string username { get; set; }
            public string email { get; set; }
            public string password_hash { get; set; }
            public string first_name { get; set; }
            public string last_name { get; set; }
            public bool active { get; set; }
        }
    }
}
```

### Controllers/AuthController.cs

```csharp
using Microsoft.AspNetCore.Mvc;
using IntraformsAPI.Services;
using IntraformsAPI.Models;

namespace IntraformsAPI.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly IAuthService _authService;

        public AuthController(IAuthService authService)
        {
            _authService = authService;
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] LoginRequest request)
        {
            if (string.IsNullOrEmpty(request.Username) || string.IsNullOrEmpty(request.Password))
            {
                return BadRequest(new { success = false, message = "Username and password are required" });
            }

            var response = await _authService.LoginAsync(request);

            if (!response.Success)
            {
                return Unauthorized(response);
            }

            return Ok(response);
        }

        [HttpPost("refresh")]
        public async Task<IActionResult> Refresh([FromHeader(Name = "Authorization")] string authorization)
        {
            if (string.IsNullOrEmpty(authorization) || !authorization.StartsWith("Bearer "))
            {
                return Unauthorized(new { success = false, message = "Refresh token required" });
            }

            var refreshToken = authorization.Substring("Bearer ".Length).Trim();
            var response = await _authService.RefreshTokenAsync(refreshToken);

            if (!response.Success)
            {
                return Unauthorized(response);
            }

            return Ok(response);
        }
    }
}
```

### Services/IUserService.cs

```csharp
using IntraformsAPI.Models;

namespace IntraformsAPI.Services
{
    public interface IUserService
    {
        Task<List<object>> GetAllUsersAsync();
        Task<object> GetUserByIdAsync(int userId);
    }
}
```

### Services/UserService.cs

```csharp
using Dapper;
using IntraformsAPI.Data;

namespace IntraformsAPI.Services
{
    public class UserService : IUserService
    {
        private readonly DapperContext _context;

        public UserService(DapperContext context)
        {
            _context = context;
        }

        public async Task<List<object>> GetAllUsersAsync()
        {
            using var connection = _context.CreateConnection();
            var result = await connection.QueryAsync("sp_GetAllUsersWithRoles", commandType: System.Data.CommandType.StoredProcedure);
            return result.Cast<object>().ToList();
        }

        public async Task<object> GetUserByIdAsync(int userId)
        {
            using var connection = _context.CreateConnection();
            
            var parameters = new DynamicParameters();
            parameters.Add("user_id", userId);

            using var multi = await connection.QueryMultipleAsync(
                "sp_GetUserWithPermissions",
                parameters,
                commandType: System.Data.CommandType.StoredProcedure
            );

            var user = await multi.ReadFirstOrDefaultAsync();
            var roles = await multi.ReadAsync();
            var permissions = await multi.ReadAsync();

            return new
            {
                user,
                roles,
                permissions
            };
        }
    }
}
```

### Controllers/UsersController.cs

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using IntraformsAPI.Services;
using IntraformsAPI.Middleware;

namespace IntraformsAPI.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize]
    public class UsersController : ControllerBase
    {
        private readonly IUserService _userService;

        public UsersController(IUserService userService)
        {
            _userService = userService;
        }

        [HttpGet]
        [RequirePermission("users.read")]
        public async Task<IActionResult> GetAll()
        {
            try
            {
                var users = await _userService.GetAllUsersAsync();
                return Ok(new { success = true, users });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { success = false, message = "Failed to fetch users", error = ex.Message });
            }
        }

        [HttpGet("{id}")]
        [RequirePermission("users.read")]
        public async Task<IActionResult> GetById(int id)
        {
            try
            {
                var result = await _userService.GetUserByIdAsync(id);
                
                if (result == null)
                {
                    return NotFound(new { success = false, message = "User not found" });
                }

                return Ok(new { success = true, data = result });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { success = false, message = "Failed to fetch user", error = ex.Message });
            }
        }
    }
}
```

---

## üîê HTTPS Certificate Setup (Development)

ASP.NET Core automatically generates a development certificate. To trust it:

```bash
# Trust the development certificate
dotnet dev-certs https --trust
```

If you need to regenerate the certificate:

```bash
# Clean existing certificates
dotnet dev-certs https --clean

# Generate new certificate
dotnet dev-certs https --trust
```

---

## üöÄ Running the Backend

```bash
# Restore dependencies
dotnet restore

# Run in development mode
dotnet run

# Or use watch mode (auto-reload on changes)
dotnet watch run

# Build for production
dotnet publish -c Release -o ./publish
```

The API will be available at: `https://localhost:5001/api`

---

## üß™ Testing the API

### Test Health Check
```bash
curl -k https://localhost:5001/api/health
```

### Test Login
```bash
curl -k -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"Admin123!"}'
```

Expected response:
```json
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "admin",
    "email": "admin@intraforms.local",
    "first_name": "System",
    "last_name": "Administrator"
  },
  "roles": [...],
  "permissions": [...]
}
```

### Test Protected Endpoint
```bash
# Replace YOUR_TOKEN with the token from login response
curl -k https://localhost:5001/api/users \
  -H "Authorization: Bearer YOUR_TOKEN"
```

### Test Token Refresh
```bash
# Replace YOUR_REFRESH_TOKEN with the refreshToken from login response
curl -k -X POST https://localhost:5001/api/auth/refresh \
  -H "Authorization: Bearer YOUR_REFRESH_TOKEN"
```

---

## üìä API Endpoints

### Authentication

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| POST | `/api/auth/login` | Login with username/password | No |
| POST | `/api/auth/refresh` | Refresh access token | Yes (Refresh Token) |

### Users

| Method | Endpoint | Description | Auth Required | Permission |
|--------|----------|-------------|---------------|------------|
| GET | `/api/users` | Get all users | Yes | users.read |
| GET | `/api/users/:id` | Get user by ID | Yes | users.read |

---

## üîí Security Checklist

- ‚úÖ Passwords hashed with bcrypt
- ‚úÖ JWT tokens with expiration
- ‚úÖ Refresh token rotation
- ‚úÖ CORS configured
- ‚úÖ Helmet security headers
- ‚úÖ Rate limiting
- ‚úÖ SQL injection protection (parameterized queries)
- ‚úÖ Environment variables for secrets
- ‚ö†Ô∏è Change JWT secrets in production
- ‚ö†Ô∏è Use real SSL certificate in production

---

## üêõ Troubleshooting

### Cannot connect to SQL Server
```bash
# Check SQL Server is running
# Verify connection string in appsettings.json
# Test connection:
# Server Explorer in Visual Studio or VS Code SQL extension
```

### HTTPS certificate errors
```bash
# Trust the certificate
dotnet dev-certs https --trust

# If still having issues, clean and regenerate
dotnet dev-certs https --clean
dotnet dev-certs https --trust
```

### CORS errors
```bash
# Verify allowed origins in appsettings.json match your Vue app URL
# Check browser console for specific error
# Ensure CORS middleware is before UseAuthorization in Program.cs
```

### JWT Token errors
```bash
# Verify JWT:Secret in appsettings.json is at least 32 characters
# Check token expiration settings
# Ensure clock skew is set to zero for testing
```

### Permission errors
```bash
# Verify user has roles assigned in user_roles table
# Verify roles have permissions in role_permissions table
# Check JWT token contains permissions claim
```

---

## üìö Next Steps

1. ‚úÖ Set up backend project structure
2. ‚úÖ Implement authentication endpoints
3. ‚úÖ Connect to SQL Server
4. ‚úÖ Test with frontend
5. üîÑ Add more API endpoints (forms, etc.)
6. üîÑ Add input validation with FluentValidation
7. üîÑ Add logging with Serilog
8. üîÑ Add automated tests with xUnit
9. üîÑ Deploy to IIS on Windows Server 2022

---

## üöÄ Optional Enhancements

### Add Swagger Documentation
Already included in the template! Access at: `https://localhost:5001/swagger`

### Add FluentValidation
```bash
dotnet add package FluentValidation.AspNetCore
```

### Add Serilog for Logging
```bash
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.File
```

### Add Entity Framework (Alternative to Dapper)
```bash
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Microsoft.EntityFrameworkCore.Tools
```

---

## üì¶ Deployment to IIS

### Prepare for Deployment

1. **Update appsettings.Production.json:**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=YOUR_PROD_SERVER;Database=SampleDB;User Id=YOUR_USER;Password=YOUR_PASSWORD;TrustServerCertificate=True;"
  },
  "Jwt": {
    "Secret": "YOUR_PRODUCTION_SECRET_AT_LEAST_32_CHARACTERS_LONG"
  },
  "Cors": {
    "AllowedOrigins": ["https://your-production-domain.com"]
  }
}
```

2. **Publish the application:**
```bash
dotnet publish -c Release -o ./publish
```

3. **Copy publish folder** to your Windows Server 2022

4. **Configure IIS:**
   - Install ASP.NET Core Hosting Bundle
   - Create new website in IIS pointing to publish folder
   - Set application pool to "No Managed Code"
   - Configure HTTPS binding with SSL certificate

---

## üÜò Support

If you encounter issues:
1. Check the console output when running `dotnet run`
2. Verify SQL Server connection string
3. Test API endpoints with curl or Postman
4. Check JWT token format in browser DevTools
5. Verify appsettings.json configuration
6. Review Swagger documentation at `/swagger`

---

## üìñ Additional Resources

- [ASP.NET Core Documentation](https://docs.microsoft.com/en-us/aspnet/core/)
- [Dapper Documentation](https://github.com/DapperLib/Dapper)
- [JWT Bearer Authentication](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/)
- [IIS Deployment Guide](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/)

---

**Your C# ASP.NET Core backend is ready to connect with the Vue frontend!** üéâ
